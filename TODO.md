Надо сделать:

Общее:
- Создание вакансии 

auth:
- Разобраться с refresh

CRUD:
- [x] CRUD Для Vacancy

Репозитории:
- [x] Убрать commit из user repo
- [x] Сделать user и employer repo максимально похожими
- Сделать базовый класс repo (мб интерфейс)
- Разобраться с UOW

Фронт:
- (DONE) Рефакторинг popup на создание вакансии 
- Рефакторинг api.js по слоям ответственности (уже сделал в папке shared, но использую ее)

Проблемы:

Могут быть проблемы с созданием пользователя:
- [x] Нет общей транзакции на создание User + Employer Сейчас UserService.create_user() создаёт пользователя, а потом (если роль employer) создаёт работодателя в отдельном сервисе, который делает commit() внутри себя. Проблемы: Если создание Employer упадёт (FK/constraint/409), пользователь уже создан и может остаться в БД (частичная запись). Ты не сможешь “атомарно” откатить всё одним rollback’ом. Идея: commit должен быть на уровне “use-case” (создать пользователя и при необходимости работодателя), а не внутри EmployerService. 

- [x] EmployerService держит self.session = repo.session — риск разных сессий Ты передаёшь employer_service извне. Если он создан с другим EmployerRepository (а тот — с другой AsyncSession), то получится: user_repo пишет в одной сессии, employer_repo пишет в другой, и атомарность/rollback невозможны. Иногда это ещё вызывает странные ошибки с состоянием объектов, refresh, “object is already attached to session”, и т.п.

- [x] В create_user нет commit/rollback вообще user_in_db = await self.user_repo.create_user(user) — но дальше ты не коммитишь созданиеj
пользователя в UserService. Что будет на практике зависит от того, что делает create_user внутри репозитория: если repo сам делает commit — ок, но тогда у тебя “commit в репозитории”, что обычно хуже; если repo делает только add/flush, то user может быть не сохранён окончательно до конца запроса; если employer_service использует ту же сессию и делает commit, то он закоммитит и пользователя “заодно” — это скрытая связь и очень неприятный сайд-эффект.